import 'package:cloud_firestore/cloud_firestore.dart';\nimport '../config/firestore_schema.dart';\n\n// Firestore Database Service for centralized Firestore operations\nclass FirestoreService {\n  final FirebaseFirestore _firestore = FirebaseFirestore.instance;\n  \n  static final FirestoreService _instance = FirestoreService._internal();\n  factory FirestoreService() => _instance;\n  FirestoreService._internal();\n\n  // Generic CRUD operations for any collection\n  Future<void> create(String collection, String docId, Map<String, dynamic> data) async {\n    try {\n      data['createdAt'] = Timestamp.now();\n      data['updatedAt'] = Timestamp.now();\n      await _firestore.collection(collection).doc(docId).set(data);\n    } catch (e) {\n      print('Error creating document in $collection: $e');\n      rethrow;\n    }\n  }\n\n  Future<void> update(String collection, String docId, Map<String, dynamic> data) async {\n    try {\n      data['updatedAt'] = Timestamp.now();\n      await _firestore.collection(collection).doc(docId).update(data);\n    } catch (e) {\n      print('Error updating document in $collection: $e');\n      rethrow;\n    }\n  }\n\n  Future<DocumentSnapshot> get(String collection, String docId) async {\n    try {\n      return await _firestore.collection(collection).doc(docId).get();\n    } catch (e) {\n      print('Error getting document from $collection: $e');\n      rethrow;\n    }\n  }\n\n  Future<void> delete(String collection, String docId) async {\n    try {\n      await _firestore.collection(collection).doc(docId).delete();\n    } catch (e) {\n      print('Error deleting document from $collection: $e');\n      rethrow;\n    }\n  }\n\n  Future<QuerySnapshot> query(String collection, {Map<String, dynamic>? where, String? orderBy, bool descending = false, int? limit}) async {\n    try {\n      Query query = _firestore.collection(collection);\n      \n      if (where != null) {\n        where.forEach((field, value) {\n          query = query.where(field, isEqualTo: value);\n        });\n      }\n      \n      if (orderBy != null) {\n        query = query.orderBy(orderBy, descending: descending);\n      }\n      \n      if (limit != null) {\n        query = query.limit(limit);\n      }\n      \n      return await query.get();\n    } catch (e) {\n      print('Error querying collection $collection: $e');\n      rethrow;\n    }\n  }\n\n  // User Operations\n  Future<void> createUser(String userId, Map<String, dynamic> userData) async {\n    await create(FirestoreCollections.users, userId, userData);\n  }\n\n  Future<DocumentSnapshot> getUser(String userId) async {\n    return await get(FirestoreCollections.users, userId);\n  }\n\n  Future<void> updateUser(String userId, Map<String, dynamic> updates) async {\n    await update(FirestoreCollections.users, userId, updates);\n  }\n\n  // Profile Operations\n  Future<void> createDonorProfile(String userId, Map<String, dynamic> profileData) async {\n    profileData['userId'] = userId;\n    await create(FirestoreCollections.donorProfiles, userId, profileData);\n  }\n\n  Future<void> createNGOProfile(String userId, Map<String, dynamic> profileData) async {\n    profileData['userId'] = userId;\n    await create(FirestoreCollections.ngoProfiles, userId, profileData);\n  }\n\n  Future<void> createVolunteerProfile(String userId, Map<String, dynamic> profileData) async {\n    profileData['userId'] = userId;\n    await create(FirestoreCollections.volunteerProfiles, userId, profileData);\n  }\n\n  Future<void> createAdminProfile(String userId, Map<String, dynamic> profileData) async {\n    profileData['userId'] = userId;\n    await create(FirestoreCollections.adminProfiles, userId, profileData);\n  }\n\n  // Food Donation Operations\n  Future<void> createFoodDonation(String donationId, Map<String, dynamic> donationData) async {\n    await create(FirestoreCollections.foodDonations, donationId, donationData);\n  }\n\n  Future<QuerySnapshot> getFoodDonationsByStatus(String status) async {\n    return await query(FirestoreCollections.foodDonations, where: {'status': status}, orderBy: 'createdAt', descending: true);\n  }\n\n  Future<QuerySnapshot> getUserFoodDonations(String userId) async {\n    return await query(FirestoreCollections.foodDonations, where: {'donorId': userId}, orderBy: 'createdAt', descending: true);\n  }\n\n  // Verification Operations\n  Future<void> createVerificationSubmission(String submissionId, Map<String, dynamic> submissionData) async {\n    await create(FirestoreCollections.verificationSubmissions, submissionId, submissionData);\n  }\n\n  Future<QuerySnapshot> getPendingVerifications() async {\n    return await query(FirestoreCollections.verificationSubmissions, where: {'status': 'pending'}, orderBy: 'submittedAt');\n  }\n\n  // Admin Task Operations\n  Future<void> createAdminTask(Map<String, dynamic> taskData) async {\n    final docRef = _firestore.collection(FirestoreCollections.adminTasks).doc();\n    taskData['createdAt'] = Timestamp.now();\n    await docRef.set(taskData);\n  }\n\n  // Audit Log Operations\n  Future<void> createAuditLog(Map<String, dynamic> logData) async {\n    logData['timestamp'] = Timestamp.now();\n    await _firestore.collection(FirestoreCollections.auditLogs).add(logData);\n  }\n\n  Future<QuerySnapshot> getAuditLogs({String? userId, String? eventType, int limit = 50}) async {\n    Map<String, dynamic>? whereClause;\n    if (userId != null) whereClause = {'userId': userId};\n    if (eventType != null) whereClause = {...?whereClause, 'eventType': eventType};\n    \n    return await query(FirestoreCollections.auditLogs, where: whereClause, orderBy: 'timestamp', descending: true, limit: limit);\n  }\n\n  // Security Operations\n  Future<void> createSecurityLog(String emailHash, Map<String, dynamic> securityData) async {\n    await create(FirestoreCollections.securityLogs, emailHash, securityData);\n  }\n\n  Future<void> updateSecurityLog(String emailHash, Map<String, dynamic> updates) async {\n    await update(FirestoreCollections.securityLogs, emailHash, updates);\n  }\n\n  Future<void> createSecurityEvent(Map<String, dynamic> eventData) async {\n    eventData['timestamp'] = Timestamp.now();\n    await _firestore.collection(FirestoreCollections.securityEvents).add(eventData);\n  }\n\n  // Session Operations\n  Future<void> createUserSession(String sessionId, Map<String, dynamic> sessionData) async {\n    await create(FirestoreCollections.userSessions, sessionId, sessionData);\n  }\n\n  Future<QuerySnapshot> getUserActiveSessions(String userId) async {\n    return await query(FirestoreCollections.userSessions, \n      where: {'userId': userId, 'isActive': true}, \n      orderBy: 'createdAt', \n      descending: true\n    );\n  }\n\n  // Notification Operations\n  Future<void> sendNotification(String userId, Map<String, dynamic> notificationData) async {\n    // Add to main notifications collection\n    await _firestore.collection(FirestoreCollections.notifications).add({\n      'userId': userId,\n      ...notificationData,\n      'createdAt': Timestamp.now(),\n    });\n    \n    // Add to user's subcollection for easier querying\n    await _firestore\n        .collection(FirestoreCollections.users)\n        .doc(userId)\n        .collection(FirestoreCollections.userNotifications)\n        .add({\n      ...notificationData,\n      'createdAt': Timestamp.now(),\n    });\n  }\n\n  Future<QuerySnapshot> getUserNotifications(String userId, {int limit = 50}) async {\n    return await _firestore\n        .collection(FirestoreCollections.users)\n        .doc(userId)\n        .collection(FirestoreCollections.userNotifications)\n        .orderBy('createdAt', descending: true)\n        .limit(limit)\n        .get();\n  }\n\n  // Donation Tracking\n  Future<void> createDonationTracking(Map<String, dynamic> trackingData) async {\n    trackingData['timestamp'] = Timestamp.now();\n    await _firestore.collection(FirestoreCollections.donationTracking).add(trackingData);\n  }\n\n  // Batch Operations\n  WriteBatch getBatch() {\n    return _firestore.batch();\n  }\n\n  Future<void> commitBatch(WriteBatch batch) async {\n    await batch.commit();\n  }\n\n  // Statistics and Analytics\n  Future<Map<String, dynamic>> getUserStatistics() async {\n    try {\n      final totalUsers = await _firestore.collection(FirestoreCollections.users).get();\n      \n      final donors = await query(FirestoreCollections.users, where: {'role': 'donor'});\n      final ngos = await query(FirestoreCollections.users, where: {'role': 'ngo'});\n      final volunteers = await query(FirestoreCollections.users, where: {'role': 'volunteer'});\n      final verified = await query(FirestoreCollections.users, where: {'status': 'verified'});\n      \n      return {\n        'totalUsers': totalUsers.docs.length,\n        'donors': donors.docs.length,\n        'ngos': ngos.docs.length,\n        'volunteers': volunteers.docs.length,\n        'verified': verified.docs.length,\n        'generatedAt': Timestamp.now(),\n      };\n    } catch (e) {\n      print('Error getting user statistics: $e');\n      return {};\n    }\n  }\n\n  Future<Map<String, dynamic>> getDonationStatistics() async {\n    try {\n      final total = await _firestore.collection(FirestoreCollections.foodDonations).get();\n      final available = await query(FirestoreCollections.foodDonations, where: {'status': 'available'});\n      final completed = await query(FirestoreCollections.foodDonations, where: {'status': 'completed'});\n      \n      return {\n        'total': total.docs.length,\n        'available': available.docs.length,\n        'completed': completed.docs.length,\n        'generatedAt': Timestamp.now(),\n      };\n    } catch (e) {\n      print('Error getting donation statistics: $e');\n      return {};\n    }\n  }\n\n  // Clean up operations\n  Future<void> cleanupExpiredSessions() async {\n    try {\n      final cutoffTime = DateTime.now().subtract(const Duration(hours: 24));\n      final expiredSessions = await _firestore\n          .collection(FirestoreCollections.userSessions)\n          .where('expiresAt', isLessThan: Timestamp.fromDate(cutoffTime))\n          .get();\n      \n      final batch = _firestore.batch();\n      for (var doc in expiredSessions.docs) {\n        batch.delete(doc.reference);\n      }\n      \n      if (expiredSessions.docs.isNotEmpty) {\n        await batch.commit();\n        print('Cleaned up ${expiredSessions.docs.length} expired sessions from Firestore');\n      }\n    } catch (e) {\n      print('Error cleaning up expired sessions: $e');\n    }\n  }\n\n  Future<void> cleanupOldAuditLogs({int retentionDays = 90}) async {\n    try {\n      final cutoffDate = DateTime.now().subtract(Duration(days: retentionDays));\n      final oldLogs = await _firestore\n          .collection(FirestoreCollections.auditLogs)\n          .where('timestamp', isLessThan: Timestamp.fromDate(cutoffDate))\n          .limit(500)\n          .get();\n      \n      if (oldLogs.docs.isNotEmpty) {\n        final batch = _firestore.batch();\n        for (var doc in oldLogs.docs) {\n          batch.delete(doc.reference);\n        }\n        await batch.commit();\n        print('Cleaned up ${oldLogs.docs.length} old audit logs from Firestore');\n      }\n    } catch (e) {\n      print('Error cleaning up old audit logs: $e');\n    }\n  }\n}